# Event-Driven Async Processing Platform

### 트래픽 폭증 환경을 위한 이벤트 기반 비동기 처리 아키텍처

> 트래픽이 폭증하는 선착순·응모 환경에서 요청을 즉시 처리하지 않고 **이벤트로 수집(SQS)**한 뒤,
> 
> 
> **Spring 기반 Worker**가 비동기 처리하고, 처리 결과 및 지연 데이터를 **분석 파이프라인(Athena)**으로 환류하는 이벤트 기반 플랫폼
> 

---

## 1. 문제 정의 및 설계 배경

### 1-1. 문제 정의

선착순 및 응모 이벤트는 특정 시점에 트래픽이 급격히 집중되는 **이벤트성 워크로드(Event-driven workload)**라는 공통된 특성을 가진다.

이러한 환경에서 사용자 요청을 **동기적으로 즉시 처리하는 구조**는 다음과 같은 구조적 문제를 야기한다.

- 서버 과부하 및 타임아웃 발생
- 재시도 및 중복 요청으로 인한 공정성 붕괴
- 처리 지연 및 실패 원인에 대한 가시성 부족

이 문제는 단순한 서버 증설이나 코드 최적화로 해결되기보다는,

**요청 처리 시점을 분리하지 않는 구조적 한계**에서 발생한다고 판단하였다.

---

### 1-2. 설계 아이디어

본 프로젝트는 위 문제를 해결하기 위해,

요청을 즉시 처리하지 않고 **요청을 이벤트로 수집한 뒤 비동기 처리**하는 구조를 채택한다.

### 핵심 개념 정의

- **요청(Request)**: 사용자가 외부 API를 통해 전달하는 참여 요청
- **이벤트(Event)**: 요청을 내부 도메인 단위로 변환한 처리 대상
- **메시지(Message)**: 이벤트를 큐(SQS)에 적재한 인프라 구현 단위
- **처리(Processing)**: 비동기 Worker의 책임

> 사용자의 요청을 즉시 처리하지 않고 내부 이벤트로 변환해 큐에 적재한 뒤,
> 
> 
> Worker가 누적된 이벤트를 비동기적으로 처리한다.
> 

### 설계 효과

이 구조를 통해 시스템은 다음을 달성한다.

- 트래픽 폭증 시에도 서버 안정성 유지
- 선착순·추첨 등 **공정성 정책을 명시적으로 모델링 및 통제**
- 처리 지연, 실패 원인, 병목 지점에 대한 추적 가능성 확보

---

### 1-3. 서버리스 기반 하이브리드 아키텍처 선택

본 프로젝트는 완전한 서버리스가 아닌,

**서버리스 기반 하이브리드 아키텍처**를 채택한다.

트래픽 흡수 및 연결부는 관리형 서비스로 단순화하되,

핵심 처리 단계는 **처리량·공정성·운영 가시성을 직접 통제**하기 위해 서버 기반 Worker(Spring)를 유지한다.

본 문서에서 ‘서버리스’는 Lambda에 한정되지 않으며,

AWS 관리형 서비스를 포함한 개념으로 사용한다.

### 주요 구성 요소

- **SQS**: 트래픽 폭증을 흡수하는 큐
- **DynamoDB**: 요청 상태 관리 및 멱등성 제어
- **EventBridge / Firehose / S3 / Athena**: 처리 결과 및 지연 데이터 분석 파이프라인

---

### 1-4. 완전 서버리스 구조를 선택하지 않은 이유

API Gateway + SQS + Lambda 기반의 완전 서버리스 구조도 가능하지만,

본 프로젝트의 핵심 요구사항과는 다음과 같은 제약이 존재한다고 판단하였다.

### 공정성·처리 제어의 한계

- FIFO SQS는 MessageGroupId 단위로만 순서 및 동시성 제어 가능
- 그룹 설계에 따라 특정 그룹 병목이 전체 지연으로 확산될 수 있음
- 선착순·추첨 등 **다중 정책을 동시에 운영할 경우 설계 및 운영 복잡도 증가**

### 시스템 목표와의 불일치

본 시스템의 목표는 단순히 p95 지연을 최소화하는 것이 아니라,

**폭주 상황에서도 예측 가능한 처리율로 요청을 줄 세워 공정하게 처리하는 것**이다.

이에 따라 핵심 처리 영역은 서버 기반 Worker로 분리하는

하이브리드 구조가 더 적합하다고 판단하였다.

---

### 1-5. 아키텍처 선택 근거 요약

| 항목 | 완전 서버리스 | 서버리스 기반 하이브리드 (본 프로젝트) | 서버풀 중심 |
| --- | --- | --- | --- |
| 트래픽 스파이크 대응 | 매우 강함 | 강함 | 직접 설계 필요 |
| 공정성·처리량 제어 | 제한적 | **정밀 제어 가능** | 가능 |
| 운영 부담 | 매우 낮음 | **Worker만 관리** | 높음 |
| 비용 특성 | 요청 기반 | **요청 + 최소 상시 비용** | 상시 비용 큼 |
| 선택 판단 | 운영 최소화 | **정확성·제어·관측 우선** | 리스크 큼 |

---

## 2. 전체 아키텍처 설계

본 프로젝트는 **요청 수집 → 비동기 처리 → 분석 환류**로 이어지는

이벤트 기반 처리 플랫폼을 목표로 한다.

### 핵심 설계 원칙

- **원칙 1**
    
    관리형 서비스는 트래픽 **흡수·적재**를 담당하고,
    
    Spring 기반 애플리케이션은 **정확성·공정성·운영 통제**가 필요한 핵심 처리만 담당한다.
    
- **원칙 2**
    
    확장은 “더 빠르게 처리”하는 것이 아니라,
    
    **공정하게 줄 세우고 예측 가능한 속도로 처리**하는 것을 목표로 한다.
    

---

## 3. 도메인 모델

### Request 상태 머신

```
RECEIVED
 → QUEUED
 → PROCESSING
 → SUCCEEDED | REJECTED | FAILED_FINAL

```

- **RECEIVED**: 요청 접수 완료
- **QUEUED**: SQS enqueue 성공 (공정성 기준 시점)
- **PROCESSING**: Worker 처리 시작
- **SUCCEEDED**: 정상 처리 완료
- **REJECTED**: 정책에 따른 정상 거절
- **FAILED_FINAL**: 재시도 불가 최종 실패

---

## 4. 공정성 모델

### 1️⃣ 선착순 (FIRST_COME)

- 공정성 기준: **queuedAt 오름차순**
- 처리 완료 순서가 아닌, **정상 접수된 순서 기준**
- DynamoDB Conditional Write로 원자적 확정

> 선착순은 “빨리 처리한 워커가 이기는 구조”가 아니라
> 
> 
> “큐에 정상 접수된 요청을 기준으로 공정하게 확정”하는 구조다.
> 

### 2️⃣ 추첨 (LOTTERY)

- 일정 시간 동안 요청 수집
- 마감 후 무작위 추첨
- 부하 안정성과 기회 균등에 초점

---

## 5. 핵심 기술적 고민

- **Idempotency**: `(eventId, userId)` 기준 단 1회 처리 보장
- **DLQ 운영 전략**: 실패 격리 + 재처리 가능 구조
- **지연 시간 모델링**: Queue / Processing / End-to-End p95 관리
- **공정성 모델 고정**: 선착순 / 추첨을 코드와 정책으로 명시

---

## 6. 역할 분리 (3인 기준)

- **Ingestion/API**: 트래픽 흡수·중복 방지
- **Async Processing**: 정확성·신뢰성 핵심
- **Logging/Analytics**: 데이터 분석 및 운영 관측

---

## 7. 최종 산출물

- 전체 아키텍처 다이어그램
- 이벤트 흐름 시퀀스
- Idempotency / DLQ / 성능 분석 문서
- 부하 테스트 결과
- CloudWatch + Athena 분석 결과
